---
title: 'Coming Back to Code in the Age of LLMs'
description: 'After almost three years of only partially following developments in flied of software engineering, returning to active development feels like stepping into a much faster paced workflow. This long pause was not intentional.'
pubDate: 'Jan 24 2026'
heroImage: '../../assets/coming-back-to-code-in-the-age-of-llm.png'
---

After almost three years of only partially following developments in flied of software engineering, returning to active development feels like stepping into a much faster paced workflow. This long pause was not intentional. Due to health related limitations, I was unable to actively develop software for an extended period of time and could only observe changes in the field from a distance.

Coming back now, the most significant change is not a new framework or programming language, but the way Large Language Models have become a natural part of everyday development.

LLMs now operate directly at the points where development usually slows down. They generate boilerplate, suggest implementations, explain unfamiliar codebases, assist with refactoring, and help write tests. Tasks that once required constant context switching now happen inline within the editor. Documentation, research, and debugging are increasingly integrated into the act of writing code itself.

The impact on productivity is noticeable. Not because developers type faster, but because interruptions in thinking and flow are reduced. Instead of moving between the IDE, browser, documentation, and issue trackers, focus stays longer on the actual problem. This shortens feedback loops and enables faster iteration.

Working with unfamiliar technologies has also changed. New libraries, frameworks, or APIs can be evaluated more quickly because LLMs provide examples, explanations, and comparisons on demand. This significantly lowers the cognitive barrier to entry and speeds up early stage technical decision making.

At the same time, the role of the developer is shifting. Less time is spent manually producing standard solutions, and more time is spent reviewing, adapting, and contextualizing suggestions. Productivity is no longer just about writing code, but about asking the right questions, validating outputs, and integrating them thoughtfully into existing systems.

Responsibility does not disappear. Architecture, security, performance, and long term maintainability cannot be delegated. LLMs change the workflow, but they do not replace technical judgment. Used well, they create time. Used uncritically, they introduce risk and technical debt.

For me, this shift feels like a new development paradigm. Software development is not only faster, but smoother. There is less friction, fewer dead ends, and more continuous progress. Returning after a long pause and experiencing this changed workflow makes it clear how strongly productivity today is shaped by tools and by how deliberately we choose to use them.